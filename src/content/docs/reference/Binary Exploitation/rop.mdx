---
title: Return Oriented Programming
---
Return Oriented Programming is a general exploit technique which involves you overwriting `$rip` with "gadgets" to execute arbitrary code.

## Gadgets
At a lower level, C code can be represented as assembly functions.

Gadgets are sequences of assembly instructions - almost like “mini” functions - which already exist somewhere within the program.

Gadgets will:
- Perform some operation on a register
  - Mathematical
  - Plus, Minus, Multiply, Divide on the target register
  - Move (mov)
  - Move the value from another register to the target register
  - Pop (pop)
  - The target register will be set to the next byte in payload
- Always end with:
  - Return (ret)
  - Pop (pop)
  - Jump (jmp)

### Finding Gadgets
There are two main ways to find gadgets:

#### Manual
[ROPgadget](https://github.com/JonathanSalwan/ROPgadget) is a Python script to find gadgets in binaries.
```bash
ROPgadget --binary vuln | grep “target register”
```

You will likely see a lot of gadgets printed out.
Most gadgets are too complicated to use - that is, there are too many requisites to use them. You need to look out for simple gadgets to use, like:
- `pop rax ; ret`
    - Set `$rax` to the next byte sent
- `mov qword ptr [rax], rdx; ret`
    - Moves the value of `$rdx` to the address of `$rax`

#### Automated
You can also automatically find gadgets with Pwntools.
```python
rop = ROP("./vuln")
print(rop.rdi) # = Gadget(0x10000004, ['pop rdi', 'ret'], ['rdi'], 0x8)
print(rop.rdi.address) # = 0x10000004
```
It will automatically find gadgets for most registers, `syscall` and `ret`.

## System Call
System Calls are how programs requests something from the OS. The exact operation and parameters are determined by arguments.

`syscall` is the assembly instruction to run a system call. The operation is determined by `$rax`, and the parameters are determined by `$rdi`, `$rsi` and `$rdx`, if necessary.

A table of system calls for Linux can be found here: [https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)

A good target is calling `sys_execve`, which runs an arbitrary program, where you can then run `/bin/sh` to spawn a shell.

## Execve ROP Chain
This is the most direct and simple ROP attack. To call `sys_execve`, you will need to:
- Set `$rax` to 59 / 0x3b
- Set `$rdi` to a pointer to a string `/bin/sh`
    - Typically, variables that would store this pointer would be called `BINSH`.
- Set `$rsi` to 0
- Set `$rdx` to 0
- Execute `syscall`

One roadblock you will face is finding a pointer to a `/bin/sh` string.

## Locating BINSH
It is possible that the string `/bin/sh` is already somewhere within the binary. Running `strings vuln | grep "/bin"` will help check for the existence of such string. Afterward, you can get the address via some decompiler.

If no such strings exist, you can create one yourself via a `mov` gadget.

First, find some empty space within the program.
1. Open the program with `pwndbg`
2. Run the program, but ensure it stops somewhere during execution (either by user input or breakpoint)
3. CTRL+C
4. Run `vmmap`. This shows sections within the running program and their use case. Usually, the DATA section has empty space.
5. Verify that the address you want to move the `/bin/sh` string is empty. In the picture, this is done by showing the first 64 bytes of the DATA region.

![](/src/assets/reference/pwn/rop/image.png)

Now, you can move the `/bin/sh` string to the address using a ROP chain.
```python
BINSH = 0x6b6000 # Free space
payload += p64(rop.rdx.address)
payload += b"/bin/sh\x00"
payload += p64(rop.rax.address)
payload += p64(BINSH)
payload += p64(mov_address) # mov qword ptr [rax], rdx; ret
```
## Example Payload
A ROP chain to call `/bin/sh` via `sys_execve` may look like this.
```python
payload = b"A"*72
payload += p64(rop.rax.address)
payload += p64(0x3b)
payload += p64(rop.rdi.address)
payload += p64(BINSH)
payload += p64(rop.rsi.address)
payload += p64(0x0)
payload += p64(rop.rbx.address)
payload += p64(0x0)
```